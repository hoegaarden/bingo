#@ namespaces = [
#@   "ns01",
#@ ]

---
apiVersion: v1
kind: Namespace
metadata:
  name: bingo

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: bingo
  namespace: bingo

#@ for ns in namespaces:
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: bingo
  namespace: #@ ns
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]
- apiGroups: ["run.tanzu.vmware.com"]
  resources: ["tanzukubernetesclusters"]
  verbs: ["create","update","get","list","delete","patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: bingo
  namespace: #@ ns
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: bingo
subjects:
- kind: ServiceAccount
  name: bingo
  namespace: bingo
#@ end

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: bingo
  namespace: bingo
spec:
  replicas: 1
  selector:
    matchLabels: &labels
      app: bingo
  template:
    metadata:
      labels: *labels
    spec:
      serviceAccountName: bingo
      initContainers:
      - name: init
        image: &kubectl bitnami/kubectl
        command: [ /scripts/init.sh ]
        volumeMounts:
        - name: shared
          mountPath: /shared
        - name: scripts
          mountPath: /scripts
      containers:
      - name: git-sync
        image: k8s.gcr.io/git-sync/git-sync:v3.6.1
        command:
        - /git-sync
        - --ssh
        - --ssh-known-hosts=false
        - --ssh-known-hosts-file=/dev/null
        - --dest=repo #! will become '--link'
        - --wait=60 #! will become '--period'
        env:
        - name: GIT_SYNC_REPO
          valueFrom:
            configMapKeyRef: { name: bingo-config, key: repo }
        - name: GIT_SYNC_BRANCH
          valueFrom:
            configMapKeyRef: { name: bingo-config, key: branch }
        - name: GIT_SYNC_REV
          valueFrom:
            configMapKeyRef: { name: bingo-config, key: rev }
        #! - name: GIT_SYNC_PERIOD
        #!   valueFrom:
        #!     configMapKeyRef: { name: bingo-config, key: period }
        - name: GIT_SYNC_EXECHOOK_COMMAND
          value: /scripts/poke.sh
        volumeMounts:
        - name: creds
          mountPath: /etc/git-secret/ssh
          readOnly: true
          subPath: ssh-key
        - name: shared
          mountPath: /shared
        - name: scripts
          mountPath: /scripts
        - name: data
          mountPath: /tmp/git
      - name: bingo
        image: *kubectl
        command: [ /scripts/bingo.sh ]
        env:
        - name: BINGO_SUB_DIR
          valueFrom:
            configMapKeyRef: { name: bingo-config, key: dir }
        volumeMounts:
        - name: shared
          mountPath: /shared
        - name: scripts
          mountPath: /scripts
        - name: data
          mountPath: /data
      volumes:
      - name: creds
        secret:
          secretName: bingo-creds
      - name: shared
        emptyDir:
          medium: Memory
      - name: data
        emptyDir:
          medium: Memory
      - name: scripts
        configMap:
          name: bingo-scripts
          defaultMode: 0755
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: bingo-scripts
  namespace: bingo
data:
  init.sh: |
    #!/usr/bin/env bash

    set -e
    set -u
    set -o pipefail

    rm -rf -- /shared/pipe
    mkfifo -m 0666 /shared/pipe
  bingo.sh: |
    #!/usr/bin/env bash

    set -e
    set -u
    set -o pipefail

    readonly ME='bingo'

    apply() {
      local cmd="$1"
      local clusterConf workloadConf
      local ns cluster

      # delete some cluster workload
      while read -r -d $'\0' workloadConf
      do
        IFS=/ read -r _ ns cluster _ <<< "$workloadConf"
        runLogged "${ns}/${cluster}" deleteClusterWorkload "$ns" "$cluster" "$workloadConf"
      done < <( find . -type f -name workload.yml.delete -print0 )

      # delete some clusters
      while read -d $'\0' -r clusterConf
      do
        IFS=/ read -r _ ns cluster _ <<< "$clusterConf"
        runLogged "${ns}/${cluster}" deleteCluster "$clusterConf"
      done < <( find . -type f -name cluster.yml.delete -print0 )

      # create some clusters
      while read -d $'\0' -r clusterConf
      do
        IFS=/ read -r _ ns cluster _ <<< "$clusterConf"
        runLogged "${ns}/${cluster}" applyCluster "$clusterConf"
      done < <( find . -type f -name cluster.yml -print0 )

      # create some cluster workload
      while read -r -d $'\0' workloadConf
      do
        IFS=/ read -r _ ns cluster _ <<< "$workloadConf"
        runLogged "${ns}/${cluster}" applyClusterWorkload "$ns" "$cluster" "$workloadConf"
      done < <( find . -type f -name workload.yml -print0 )
    }

    applyCluster() {
      echo >&2 "applying:"
      kubectl apply --field-manager="$ME" -f "$1" || {
        echo >&2 'Issues on apply!'
        return # well, ignore and retry on next cycle
      }
      echo >&2 "applying done."
    }

    deleteCluster() {
      echo >&2 "deleting:"
      kubectl delete --field-manager="$ME" -f "$1" || {
        echo >&2 'Issues on deletion!'
        return # well, ignore and retry on next cycle
      }
      echo >&2 "deleting done."
    }

    applyClusterWorkload() {
      echo >&2 "applying workload to remote cluster $1/$2:"
      kubectl --kubeconfig <(getKubeconf "$1" "$2") apply --field-manager="$ME" -f "$3" || {
        echo >&2 'Issues on apply!'
        return # well, ignore and retry on next cycle
      }
      echo >&2 "applying done."
    }

    deleteClusterWorkload() {
      echo >&2 "deleting workload on remote cluster $1/$2:"
      kubectl --kubeconfig <(getKubeconf "$1" "$2") delete --field-manager="$ME" -f "$3" || {
        echo >&2 'Issues on deletion!'
        return # well, ignore and retry on next cycle
      }
      echo >&2 "deleting done."
    }

    getKubeconf() {
      kubectl --namespace "$1" get secret "${2}-kubeconfig" \
        -o go-template='{{ .data.value | base64decode }}'
    }

    runLogged() {
      local logPrefix="$1"
      shift

      "$@" \
          >  >( awk -v p="${logPrefix},O" '{ print p ": " $0 }' ) \
          2> >( awk -v p="${logPrefix},E" '{ print p ": " $0 }' >&2 )
    }

    main() {
      local cmd

      while true
      do
        read -r cmd < /shared/pipe

        case "$cmd" in
          reload)
            echo >&2 'reloading bingo runner'
            exec "$0" "$@"
            ;;
          exit|quit|stop)
            echo >&2 'stopping bingo runner'
            exit 10
            ;;
          *)
            cd "/data/repo/${BINGO_SUB_DIR}"
            echo >&2 "got '$cmd', running apply in ${PWD}"
            apply "$cmd"
            ;;
        esac
      done
    }

    rc=0
    main "$@" || rc=$?

    if [[ $rc -gt 0 ]] ; then
      echo >&2 "bingo runner's main exited with: $rc"
      exit $rc
    fi
  poke.sh: |
    #!/bin/sh

    set -e
    set -u

    echo 'apply' > /shared/pipe
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: bingo-config
  namespace: bingo
data:
  repo: git@github.com:hoegaarden/bingo
  branch: main
  rev: HEAD
  #! period: 1m
  dir: example
---
#! apiVersion: v1
#! kind: Secret
#! metadata:
#!   name: bingo-creds
#!   namespace: bingo
#! stringData:
#!   ssh-key: |
#!     -----BEGIN OPENSSH PRIVATE KEY-----
#!     b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
#!       [...]
#!     Nonha/zPwQDL8AAAALaG9ybGhAYmx1cHA=
#!     -----END OPENSSH PRIVATE KEY-----
